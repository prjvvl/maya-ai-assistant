<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>TTS Test</title>
		<style>
			body {
				font-family: Arial, sans-serif;
				padding: 20px;
			}
			.test-area {
				margin: 20px 0;
			}
			button {
				margin: 5px;
				padding: 10px 15px;
			}
			.status {
				margin: 10px 0;
				font-weight: bold;
			}
			.text-sample {
				background: #f5f5f5;
				padding: 15px;
				border-radius: 5px;
				margin: 10px 0;
			}
		</style>
	</head>
	<body>
		<h1>Text-to-Speech Testing</h1>

		<div class="status" id="status">Ready</div>

		<div class="test-area">
			<h3>Test Samples:</h3>

			<div class="text-sample">
				<h4>Short Text:</h4>
				<p id="short-text">Hello! This is a short test message for text-to-speech functionality.</p>
				<button onclick="testTTS('short-text')">Speak Short Text</button>
			</div>

			<div class="text-sample">
				<h4>Medium Text:</h4>
				<p id="medium-text">
					This is a medium length text sample that contains multiple sentences. It should test the
					chunking functionality of our improved text-to-speech system. The speech synthesis should
					handle this smoothly without cutting off in the middle. Each sentence should flow
					naturally into the next one, maintaining good speech quality throughout the entire
					passage.
				</p>
				<button onclick="testTTS('medium-text')">Speak Medium Text</button>
			</div>

			<div class="text-sample">
				<h4>Long Text:</h4>
				<p id="long-text">
					This is a comprehensive test of the text-to-speech functionality with a very long passage
					that will definitely exceed the typical browser limits for speech synthesis. The previous
					version of the system would often stop speaking after just a few words when dealing with
					responses of this length. However, with our new chunking system, the text is intelligently
					split into smaller segments that are processed sequentially. Each chunk is given proper
					timing to ensure smooth delivery. The system includes retry logic to handle any temporary
					failures, timeout management to prevent hanging, and robust error handling to gracefully
					recover from issues. This approach ensures that users hear complete responses regardless
					of their length. The chunks are split at natural boundaries like sentences and commas to
					maintain speech flow and comprehension. Additionally, we've added visual feedback so users
					know when the AI is speaking, which improves the overall user experience significantly.
				</p>
				<button onclick="testTTS('long-text')">Speak Long Text</button>
			</div>
		</div>

		<div class="test-area">
			<button onclick="stopSpeech()">Stop Speech</button>
			<button onclick="getSpeechStatus()">Get Status</button>
		</div>

		<script>
			const statusEl = document.getElementById('status');

			function updateStatus(message) {
				statusEl.textContent = message;
				console.log('Status:', message);
			}

			function testTTS(elementId) {
				const element = document.getElementById(elementId);
				const text = element.textContent;

				updateStatus('Starting speech...');

				// Cancel any ongoing speech
				speechSynthesis.cancel();

				// Split text into chunks (similar to our implementation)
				const chunks = splitTextIntoChunks(text, 200);
				console.log(`Split into ${chunks.length} chunks:`, chunks);

				speakChunks(chunks, 0);
			}

			function splitTextIntoChunks(text, maxLength) {
				if (text.length <= maxLength) {
					return [text];
				}

				const chunks = [];
				const sentences = text.split(/[.!?]+/).filter((s) => s.trim().length > 0);

				let currentChunk = '';

				for (const sentence of sentences) {
					const trimmedSentence = sentence.trim();
					if (!trimmedSentence) continue;

					const sentenceWithPunct = trimmedSentence + '.';

					if (currentChunk.length + sentenceWithPunct.length > maxLength) {
						if (currentChunk) {
							chunks.push(currentChunk.trim());
							currentChunk = '';
						}
						currentChunk = sentenceWithPunct;
					} else {
						currentChunk += (currentChunk ? ' ' : '') + sentenceWithPunct;
					}
				}

				if (currentChunk.trim()) {
					chunks.push(currentChunk.trim());
				}

				return chunks.filter((chunk) => chunk.length > 0);
			}

			async function speakChunks(chunks, index) {
				if (index >= chunks.length) {
					updateStatus('Speech completed!');
					return;
				}

				updateStatus(`Speaking chunk ${index + 1}/${chunks.length}`);

				const chunk = chunks[index];
				console.log(`Speaking chunk ${index + 1}:`, chunk.substring(0, 50) + '...');

				try {
					await speakChunk(chunk);
					// Small delay between chunks
					await new Promise((resolve) => setTimeout(resolve, 300));
					// Continue with next chunk
					speakChunks(chunks, index + 1);
				} catch (error) {
					console.error('Speech error:', error);
					updateStatus('Speech error: ' + error.message);
				}
			}

			function speakChunk(text) {
				return new Promise((resolve, reject) => {
					const utterance = new SpeechSynthesisUtterance(text);

					utterance.rate = 0.9;
					utterance.pitch = 1.3;
					utterance.volume = 1.0;

					const timeout = setTimeout(
						() => {
							speechSynthesis.cancel();
							reject(new Error('Speech timeout'));
						},
						Math.max(text.length * 100 + 3000, 5000)
					);

					utterance.onend = () => {
						clearTimeout(timeout);
						resolve();
					};

					utterance.onerror = (event) => {
						clearTimeout(timeout);
						reject(new Error(`Speech error: ${event.error}`));
					};

					speechSynthesis.speak(utterance);
				});
			}

			function stopSpeech() {
				speechSynthesis.cancel();
				updateStatus('Speech stopped');
			}

			function getSpeechStatus() {
				const status = {
					speaking: speechSynthesis.speaking,
					pending: speechSynthesis.pending,
					paused: speechSynthesis.paused
				};
				updateStatus(
					`Speaking: ${status.speaking}, Pending: ${status.pending}, Paused: ${status.paused}`
				);
				console.log('Speech status:', status);
			}

			// Update status periodically
			setInterval(() => {
				if (speechSynthesis.speaking) {
					updateStatus('Speaking...');
				}
			}, 1000);
		</script>
	</body>
</html>
